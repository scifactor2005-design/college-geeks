<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trees & Graphs - College Geeks</title>
    <link rel="shortcut icon" href="C_icon.png" type="image/x-icon">
    <link rel="stylesheet" href="style.css">
    <style>
        .page-header {
            text-align: center;
            padding: 60px 20px;
            background: linear-gradient(135deg, #4c1d95 0%, #7c3aed 100%);
            color: white;
            border-radius: 0 0 20px 20px;
            margin-bottom: 30px;
        }

        .page-header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .content-section {
            max-width: 1000px;
            margin: 0 auto 40px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .content-section h2 {
            color: var(--link-color);
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .code-example {
            background: #1e293b;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
        }
    </style>
</head>

<body>
    <div id="dynamic-bg"></div>
    <nav class="navbar">
        <ul>
            <li><a href="College_Geeks.html">Home</a></li>
            <li><a href="dsa.html">DSA</a></li>
            <li><a href="computer_org.html">Computer Org</a></li>
            <li><a href="compiler_design.html">Compiler Design</a></li>
            <li><a href="toc.html">Theory of Comp</a></li>
            <li><a href="ai.html">AI</a></li>
            <li><a href="ml.html">Machine Learning</a></li>
            <li><a href="dl.html">Deep Learning</a></li>
        </ul>
    </nav>
    <div class="page-header">
        <h1>Trees & Graphs</h1>
        <p>Hierarchical and networked data structures</p>
    </div>
    <div class="content-section">
        <h2>Binary Trees</h2>
        <p>A tree data structure where each node has at most two children (left and right). Trees are hierarchical
            structures used to represent relationships.</p>
        <h3>Tree Node Structure:</h3>
        <div class="code-example">
            <pre>
struct TreeNode {
    int data;
    TreeNode* left;
    TreeNode* right;
    
    TreeNode(int val) : data(val), left(nullptr), right(nullptr) {}
};
</pre>
        </div>
        <h3>Tree Traversals:</h3>
        <ul>
            <li><strong>Inorder (Left-Root-Right):</strong> Gives sorted order in BST</li>
            <li><strong>Preorder (Root-Left-Right):</strong> Used for creating copy of tree</li>
            <li><strong>Postorder (Left-Right-Root):</strong> Used for deleting tree</li>
            <li><strong>Level Order:</strong> BFS traversal</li>
        </ul>
        <div class="code-example">
            <pre>
// Inorder Traversal
void inorder(TreeNode* root) {
    if (root == nullptr) return;
    inorder(root->left);
    cout << root->data << " ";
    inorder(root->right);
}

// Level Order Traversal
void levelOrder(TreeNode* root) {
    if (root == nullptr) return;
    queue&lt;TreeNode*&gt; q;
    q.push(root);
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        cout << node->data << " ";
        if (node->left) q.push(node->left);
        if (node->right) q.push(node->right);
    }
}
</pre>
        </div>
    </div>
    <div class="content-section">
        <h2>Binary Search Tree (BST)</h2>
        <p>A binary tree where for each node: left subtree contains smaller values, right subtree contains larger
            values.</p>
        <h3>BST Operations:</h3>
        <div class="code-example">
            <pre>
// Insert in BST
TreeNode* insert(TreeNode* root, int val) {
    if (root == nullptr) return new TreeNode(val);
    if (val < root->data)
        root->left = insert(root->left, val);
    else
        root->right = insert(root->right, val);
    return root;
}

// Search in BST
bool search(TreeNode* root, int val) {
    if (root == nullptr) return false;
    if (root->data == val) return true;
    if (val < root->data)
        return search(root->left, val);
    return search(root->right, val);
}
</pre>
        </div>
    </div>
    <div class="content-section">
        <h2>Graphs</h2>
        <p>A graph consists of vertices (nodes) connected by edges. Graphs can be directed or undirected, weighted or
            unweighted.</p>
        <h3>Graph Representation:</h3>
        <div class="code-example">
            <pre>
// Adjacency List
vector&lt;int&gt; adj[V];  // V is number of vertices

// Add edge
void addEdge(int u, int v) {
    adj[u].push_back(v);
    adj[v].push_back(u);  // For undirected graph
}
</pre>
        </div>
        <h3>Graph Traversals:</h3>
        <h4>Depth First Search (DFS):</h4>
        <div class="code-example">
            <pre>
void DFS(int v, vector&lt;bool&gt;& visited) {
    visited[v] = true;
    cout << v << " ";
    
    for (int u : adj[v]) {
        if (!visited[u])
            DFS(u, visited);
    }
}
</pre>
        </div>
        <h4>Breadth First Search (BFS):</h4>
        <div class="code-example">
            <pre>
void BFS(int start) {
    vector&lt;bool&gt; visited(V, false);
    queue&lt;int&gt; q;
    
    visited[start] = true;
    q.push(start);
    
    while (!q.empty()) {
        int v = q.front();
        q.pop();
        cout << v << " ";
        
        for (int u : adj[v]) {
            if (!visited[u]) {
                visited[u] = true;
                q.push(u);
            }
        }
    }
}
</pre>
        </div>
    </div>
    <div class="content-section">
        <h2>Applications</h2>
        <ul>
            <li><strong>File Systems:</strong> Directory structure (trees)</li>
            <li><strong>Social Networks:</strong> Friend connections (graphs)</li>
            <li><strong>Routing Algorithms:</strong> Finding shortest paths</li>
            <li><strong>Database Indexing:</strong> B-trees for efficient search</li>
            <li><strong>Decision Making:</strong> Decision trees in AI/ML</li>
            <li><strong>Web Crawling:</strong> Graph traversal algorithms</li>
        </ul>
    </div>
    <footer>
        <p>&copy; 2024 College Geeks. All rights reserved.</p>
    </footer>
    <script>(function () { const bg = document.getElementById('dynamic-bg'); const slides = [{ bg: 'linear-gradient(135deg, #f5f3ff 0%, #ede9fe 100%)', fg: '#1e1b4b', link: '#241f63' }]; function applySlide(i) { const slide = slides[i]; bg.style.background = slide.bg; document.documentElement.style.setProperty('--fg', slide.fg); document.documentElement.style.setProperty('--link-color', slide.link); } applySlide(0); })();</script>
</body>

</html>